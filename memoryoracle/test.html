<!DOCTYPE html>
<html>
   <meta charset="utf-8">
   <head>
      <style>

      .link {
         stroke: #000;
         stroke-width: 1.5px;
         fill: none;
      }

      .node {
      fill: #000;
      stroke: #fff;
      stroke-width: 1.5px;
      }

      </style>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <script type="text/javascript">
      </script>
   </head>
   <body>
      <script src="d3.js"></script>
   <div id="viz"></div>
    <script>
var urls = {
   arrays: "arrays.json",
   pointers: "pointers.json",
   structs: "structs.json",
   values: "values.json"
};

var memory = { arrays: null, pointers: null, structs: null, values: null }

function load(v) {
   return $.ajax({
      url: v + ".json"
   })
   .done(function( data ){
      memory[v] = data;
   });
}
function name(d) { return d.name; }
function group(d) { return d.group; }

var color = d3.scale.category10();
//function colorByGroup(d) { return color(group(d)); }

var width = 1920,
    height = 1080;

var projection = d3.geo.albers()
        .center([0, 55.4])
        .rotate([4.4, 0])
        .parallels([50, 60])
        .scale(1200 * 5)
        .translate([width / 2, height / 2]);

var svg = d3.select('#viz')
    .append('svg')
    .attr('width', width)
    .attr('height', height);

var node, link;

//var voronoi = d3.geom.voronoi()
//    .x(function(d) { return d.x; })
//    .y(function(d) { return d.y; })
//    .clipExtent([[-10, -10], [width+10, height+10]]);

function recenterVoronoi(nodes) {
    var shapes = [];
    voronoi(nodes).forEach(function(d) {
        if ( !d.length ) return;
        var n = [];
        d.forEach(function(c){
            n.push([ c[0] - d.point.x, c[1] - d.point.y ]);
        });
        n.point = d.point;
        shapes.push(n);
    });
    return shapes;
}

var force = d3.layout.force()
    .charge(-2000)
    .friction(0.3)
    .linkDistance(50)
    .size([width, height]);

var labelForce = d3.layout.force()
   .charge(-50)
   .friction(0.1)
   .gravity(0)
   .size([width, height]);

var nodeSet = new Set();
var edgeSet = new Set();

function drag_all(selection) {
   force.drag(selection);
   labelForce.drag(selection);
}

//d3.json('json.json', function(err, data) {
function draw_graph(data) {

    $.each(data, function(className, classData) {
      //nodeSet.add(k);
      $.each(classData, function(address, value) {
         $.each(value, function(name, nameData) {
            assemble_graph(address, nameData);
         });
      });
    });
    data.nodes = new Array();
    data.links = new Array();
    var n;
    var n1;
    var n2;
    var nodeMap = new Map();
    for ( v of edgeSet ) {
       nodeSet.add(v[0])
       nodeSet.add(v[1])
    }
    var count = 0;
    for ( n of nodeSet ) {
       nodeMap.set(n, count);
       ++count;
    }
    for ( v of nodeSet ) {
       n = {id: v, weight: 1};
       data.nodes.push(n);
    }
    for ( v of edgeSet ) {
       src = nodeMap.get(v[0]);
       trg = nodeMap.get(v[1]);
       data.links.push({source: src, target: trg, value: 1});
    }

    var gnodes = svg.selectAll('g.node')
       .data(data.nodes)
       .enter()
       .append('g')
       .classed('gnode', true)
       .call(labelForce.drag)

    link = svg.selectAll('.link')
        .data( data.links )
        .enter().append('path')
        .attr('class', 'link')
        .attr('marker-end', 'url(#arrowhead)')
        .style("stroke-width", function(d) { return Math.sqrt(d.value); });

    svg.append('defs').append('marker')
        .attr({'id':'arrowhead',
               'viewBox':'-0 -5 10 10',
               'refX':15,
               'refY':0,
               //'markerUnits':'strokeWidth',
               'orient':'auto',
               'markerWidth':10,
               'markerHeight':10,
               'xoverflow':'visible'})
        .append('svg:path')
            .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
            .attr('fill', '#000')
            .attr('stroke','#000');

    node = gnodes.append("circle")
       .attr('title', name)
       .attr("r", 5)
       .attr("class", "node");

    var foci = [];
    var label = gnodes.append("foreignObject").attr("class", "label");

    var labelNodes = new Array();
    label[0].forEach(function(l, i) {
       labelNodes[i] = l.__data__;
    });

    label.html(function(d) {
       var names = [];
       if(data.pointers[d.id]) {
          $.each(data.pointers[d.id], function(ob, v) {
             names.push(ob);
          });
       }
       if(data.arrays[d.id]) {
          $.each(data.arrays[d.id], function(ob, v) {
             names.push(ob);
          });
       }
       if(data.structs[d.id]) {
          $.each(data.structs[d.id], function(ob, v) {
             names.push(ob);
          });
       }
       if(data.values[d.id]) {
          $.each(data.values[d.id], function(ob, v) {
             names.push(ob + " = " + v.value);
          });
       }
        return '<div style="text-shadow: 0 0 15px #FF8888">' + names + '<\/div>';
    });
    label[0].forEach(function(d, i) {
       foci.push({x: 0, y: 0});
    });



    $("foreignObject").attr("width", 200);
    $("foreignObject").attr("height", 200);


    node.append('circle')
        .attr('r', 30)
        //.attr('fill', colorByGroup)
        .attr('fill-opacity', 0.5);

    node.append('circle')
        .attr('r', 4)
        .attr('stroke', 'black');

    var logged = false;

    var tickTravel = new Object();

labelForce.on("tick", function(evnt) {
    link.attr("d", function(d) {
      d.x1 = d.source.x;
      d.x2 = d.target.x;
      d.y1 = d.source.y;
      d.y2 = d.target.y;
  var x1 = d.source.x,
      y1 = d.source.y,
      x2 = d.target.x,
      y2 = d.target.y,
      dx = x2 - x1,
      dy = y2 - y1,
      dr = Math.sqrt(dx * dx + dy * dy),
      // Defaults for normal edge.
      drx = dr,
      dry = dr,
      xRotation = 0, // degrees
      largeArc = 0, // 1 or 0
      sweep = 1; // 1 or 0

      tickTravel.y = dy;
      tickTravel.r = dr;
      tickTravel.x = dx;


      // Self edge.
      if ( x1 === x2 && y1 === y2 ) {
        // Fiddle with this angle to get loop oriented.
        xRotation = -45;

        // Needs to be 1.
        largeArc = 1;

        // Change sweep to change orientation of loop.
        //sweep = 0;

        // Make drx and dry different to get an ellipse
        // instead of a circle.
        drx = 15;
        dry = 25;

        // For whatever reason the arc collapses to a point if the beginning
        // and ending points of the arc are the same, so kludge it.
        x2 = x2 + 1;
        y2 = y2 + 1;
      }

 return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
    });
   force2.resume();

   var k = 0.1 * evnt.alpha;
   label.attr("transform", function(d, i) {
      foci[i] = {x: d.x, y: d.y};
     return "translate(" + [d.x - 100, d.y] + ")";
   });
  gnodes.attr("transform", function(d, i) {
      strng = "translate(" + [(foci[i].x - d.x) / tickTravel.x, (foci[i].y - d.y) / tickTravel.y] + ")";
      return strng;
  });


});


var force2 = d3.layout.force().nodes(nodes).links(links).gravity(0).linkDistance(0).linkStrength(8).charge(-100).size([width, height]);
force2.start();

var anchorLink = svg.selectAll("line.anchorLink").data(links)//.enter().append("svg:line").attr("class", "anchorLink").style("stroke", "#999");

var anchorNode = svg.selectAll("g.anchorNode").data(force2.nodes()).enter().append("svg:g").attr("class", "anchorNode");
anchorNode.append("svg:circle").attr("r", 0).style("fill", "#FFF");
anchorNode.append("svg:text").text(function(d, i) {
   return i % 2 == 0 ? "" : d.node.label
}).style("fill", "#555").style("font-family", "Arial").style("font-size", 12);

var updateLink = function() {
   this.attr("x1", function(d) {
      return d.source.x;
   }).attr("y1", function(d) {
      return d.source.y;
   }).attr("x2", function(d) {
      return d.target.x;
   }).attr("y2", function(d) {
      return d.target.y;
   });

}

var updateNode = function() {
   this.attr("transform", function(d) {
      return "translate(" + d.x + "," + d.y + ")";
   });

}


force.on("tick", function() {

   force2.resume();

   node.call(updateNode);

   anchorNode.each(function(d, i) {
      if(i % 2 == 0) {
         d.x = d.node.x;
         d.y = d.node.y;
      } else {
         var b = this.childNodes[1].getBBox();
         console.log("bbox = ", b);

         var diffX = d.x - d.node.x;
         var diffY = d.y - d.node.y;

         var dist = Math.sqrt(diffX * diffX + diffY * diffY);

         var shiftX = b.width * (diffX - dist) / (dist * 2);
         shiftX = Math.max(-b.width, Math.min(0, shiftX));
         var shiftY = 5;
         this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
      }
   });


   anchorNode.call(updateNode);

   link.call(updateLink);
   anchorLink.call(updateLink);

});



//  force
//      .nodes( data.nodes )
//      .links( data.links )
//      .start();

}

var color = d3.scale.category10();

var nodes = [],
    links = [];

var node = svg.selectAll(".node"),
    link = svg.selectAll(".link");
var nodeSet = new Set();
var edgeSet = new Set();

var edgeList = new Object();


function assemble_graph(source, value) {
   var v = value;
   var n2;
   if(v.parents) {
      for (var n2 in v.parents.pointer) {
         nodeSet.add(n2);
         edgeSet.add([n2, source]);
      }
      for (var n2 in v.parents.array) {
         nodeSet.add(n2);
         edgeSet.add([n2, source]);
      }
      for (var n2 in v.parents.struct) {
         nodeSet.add(n2);
         edgeSet.add([n2, source]);
      }
   }
}
$.when(load("arrays"), load("pointers"), load("structs"), load("values"))
.done(function() { draw_graph(memory); });

var ws = new WebSocket("ws://localhost:8765");

ws.onmessage = function (event){
   console.log(event.data);
   $("body").append("<div>" + event.data + "</div>");
}
      </script>
   </body>

</html>
