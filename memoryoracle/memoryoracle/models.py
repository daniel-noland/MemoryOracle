#!/usr/bin/env python# -*- encoding UTF-8 -*-
"""
File containing all classes representing memory addressable
objects in the debugged program.
"""

import gdb
import tracked
import typed
import registry
import frame
# import templatable
from copy import deepcopy
import re
import descriptions
# import weakref
import traceback
import json
# from uuid import uuid4 as uuid

import pymongo

import mongoengine

# NOTE: The read_preference should not be needed.  This is a workaround for a
# bug in pymongo.  (http://goo.gl/Somoeu)
connection = mongoengine.connect('memoryoracle',
                    read_preference=\
                            pymongo.read_preferences.ReadPreference.PRIMARY)

db = connection.memoryoracle

class Instance(mongoengine.Document):

    name = mongoengine.StringField()

class Execution(mongoengine.Document):
    """
    *Concrete* class representing a particular call to an executable.
    """
    arguments = mongoengine.StringField()
    start_time = mongoengine.ComplexDateTimeField()
    end_time = mongoengine.ComplexDateTimeField()
    objects = mongoengine.ListField(mongoengine.ReferenceField('Memory'))

    @staticmethod
    def set_execution(execution):
        Execution._current = execution

    @classmethod
    def current(cls):
        return cls._current


class Executable(mongoengine.EmbeddedDocument):
    """
    *Concrete* class representing a executable file generated by running
    build on a commit
    """
    name = mongoengine.StringField()
    path = mongoengine.StringField()
    hash_sha256 = mongoengine.StringField()
    hash_sha384 = mongoengine.StringField()
    hash_sha512 = mongoengine.StringField()
    version = mongoengine.StringField()
    executions = mongoengine.ListField(mongoengine.ReferenceField(Execution))


class Commit(mongoengine.Document):
    """
    *Concrete* class representing a version control system commit.
    """
    vcs_hash = mongoengine.StringField()
    executables = mongoengine.EmbeddedDocumentListField(Executable)


class Memory(typed.Typed):
    """
    *Abstract* class representing a instance of an object with a type.

    This class enforces that the object have a memory address
    in the debugge, or that an appropriate address is specified.
    """

    address = mongoengine.StringField()
    name = mongoengine.StringField()
    frame = mongoengine.StringField()
    execution = mongoengine.ReferenceField(Execution)
    # description = mongoengine.ReferenceField(descriptions.Description)
    type = mongoengine.StringField()
    dynamic_type = mongoengine.StringField()
    unaliased_type = mongoengine.StringField()
    range_start = mongoengine.IntField()
    range_end = mongoengine.IntField()
    children = mongoengine.ListField(mongoengine.ReferenceField('Memory'))
    value = mongoengine.StringField()

    meta = {
        'allow_inheritance': True,
        'indexes': [
            'address',
            'frame'
        ]
    }

    class DuplicateAddress(Exception):
        pass

    @property
    def index(self):
        return str(self.address)

    class NewObject(Exception):
        pass

    @classmethod
    def _fetch(cls, description):
        if description is None:
            raise Exception("Description required to fetch object!")

        execution = description.execution
        frameDescription = descriptions.MemoryDescription("myframe", address=str(gdb.selected_frame()))

        # TODO: replace selected_frame call with something more flexible
        frm = frame.Frame(gdb.selected_frame())
        address = description.address
        memories = cls.objects(
            execution=execution,
            frame=str(frm),
            address=address
        )
        if len(memories) > 1:
            raise Memory.DuplicateAddress("Duplicate address for memory!")
        elif len(memories) == 0:
            raise Memory.NewObject("New object found")
        return memories[0]

    @classmethod
    def factory(cls, **kwargs):
        """
        build an object based on a description, or fetch that object
        from the database if it already exists.
        """
        desc = kwargs["descript"]

        if desc.execution is not None:
            Memory._set_execution(desc.execution)

        try:
            return cls._fetch(desc)
        except Memory.NewObject:
            otherArgs = {k: v for k, v in kwargs.items() if k != "descript"}
            otherArgs.update(desc.dict)
            return cls(**otherArgs)


class Call(Memory):
    """
    *Concrete* class representing a particaular call to a function.

    This includes class / struct member functions, but does not
    include gdb Xmethods or similar.
    """
    repository = dict()
    _typeHandlerCode = gdb.TYPE_CODE_FUNC
    _updateTracker = set()
    _watchers = dict()


class Structure(Memory):
    """
    *Concrete" class representing a specific memory structure.

    This includes all instances of classes and structs in C++.
    It is worth noting that the first member variable of a
    memory structure has the same address as the memory structure,
    and may thus share a node in the memory topology.
    """
    _typeHandlerCode = gdb.TYPE_CODE_STRUCT


class VolatileDecorator(Memory):
    """
    *Decorator* class to indicate an addressable is volatile.
    """
    pass


class RegisterDecorator(Memory):
    """
    *Decorator* class to decorate an addressable as being marked register.
    """
    pass


class ExternDecorator(Memory):
    """
    *Decorator* class to decorate an addressable as being marked extern.
    """
    pass


class MemberDecorator(Memory):
    """
    *Decorator* class to decorate an addressable as being a member value
    of another class.
    """
    pass


class Array(Memory):
    """
    *Concrete* class to represent an array in the debugge.
    """
    target_type = mongoengine.StringField() ## TODO: upgrade this to ref field





class Primitive(Memory):
    """
    *Abstract* class to represent a primitive data type in the debugge.

    Primitive data types are directly printable types such as int and double.
    """

    # repository = dict()
    # _updateTracker = dict()

    def _pull(self):
        self.value = self.val_string()

    def val_string(self):
        """
        Get the printed value of a primitive object
        """
        with frame.Selector(self.frame) as s:
            ## TODO: Find a way to print values without messing with the $# var
            # in the gdb interface.
            gdbPrint = gdb.execute("print " + self.name, False, True)
            ## TODO: If we can't fix the $# var, we may as well use it.
            ## this is free information we may as well store for the user's use.
            ansSections = gdbPrint[:-1].split(" = ")[1:]
            return " ".join(ansSections)


class Pointer(Primitive):
    """
    *Concrete* class to represent a pointer in the debugge.
    """
    target = mongoengine.ReferenceField('Memory')

    _typeHandlerCode = gdb.TYPE_CODE_PTR


class Int(Primitive):
    """
    *Concrete* class to represent integral types.
    """
    _typeHandlerCode = gdb.TYPE_CODE_INT



class Float(Primitive):
    """
    *Concrete* class to represent floating point primitivies.
    """
    _typeHandlerCode = gdb.TYPE_CODE_FLT



class CharString(Pointer):
    """
    *Concrete* class to represent an old style null terminated C string.
    """
    pass


class ConstDecorator(Memory):
    """
    *Decorator* class to decorate an addressable as being marked const.
    """
    pass


class StaticDecorator(Memory):
    """
    *Decorator* class to decorate an addressable as being marked static.
    """
    pass


class Void(Memory):
    """
    *Concrete* class to describe an object of the type void
    """
    pass




